{"version":3,"sources":["../src/markets.js"],"names":["methodName","functionInputs","name","type","marketAddress","outcomeTokenIndex","outcomeTokenCount","opts","txOpts","approvalAmount","approvalResetAmount","contracts","Market","at","market","Token","Event","eventContract","collateralToken","lmsrMarketMaker","calcCost","baseCost","calcMarketFee","cost","add","txPromises","txRequiredEventNames","buyer","from","defaultAccount","allowance","marketAllowance","lt","push","approve","web3","toBigNumber","buy","all","res","i","txRequiredEvents","map","purchaseEvent","length","args","outcomeTokenCost","plus","marketFees","buyOutcomeTokens","outcomeTokens","outcomeToken","calcProfit","baseProfit","minProfit","sub","seller","sell","saleEvent","outcomeTokenProfit","minus","sellOutcomeTokens","createMarket","self","callerContract","marketFactory","standardMarketFactory","callerABI","StandardMarketFactory","abi","eventName","eventArgName","resultContract","argAliases","event","estimateGas","using","gasStats","averageGasUsed","Error"],"mappings":"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","file":"markets.js","sourcesContent":["import _ from 'lodash'\nimport {\n    normalizeWeb3Args,\n    wrapWeb3Function,\n    requireEventFromTXResult,\n} from './utils'\n\n/**\n * Creates a market.\n *\n * Note: this method is asynchronous and will return a Promise\n *\n * @function\n * @param {(Contract|string)} opts.event - The forwarded oracle contract or its address\n * @param {(Contract|string)} opts.marketMaker - The collateral token contract or its address\n * @param {(number|string|BigNumber)} opts.fee - The fee factor. Specifying 1,000,000 corresponds to 100%, 50,000 corresponds to 5%, etc.\n * @param {(Contract|string)} [opts.marketFactory={@link Gnosis#standardMarketFactory}] - The factory contract\n * @returns {Contract} The created market contract instance. If marketFactory is [StandardMarketFactory](https://gnosis.github.io/gnosis-contracts/docs/StandardMarketFactory/), this should be a [StandardMarket](https://gnosis.github.io/gnosis-contracts/docs/StandardMarket/)\n * @alias Gnosis#createMarket\n */\nexport const createMarket = wrapWeb3Function((self, opts) => ({\n    callerContract: opts.marketFactory || self.standardMarketFactory,\n    callerABI: self.contracts.StandardMarketFactory.abi,\n    methodName: 'createMarket',\n    eventName: 'StandardMarketCreation',\n    eventArgName: 'market',\n    resultContract: self.contracts.Market,\n    argAliases: {\n        event: 'eventContract',\n    }\n}))\n\n/**\n * Buys outcome tokens. If you have ether and plan on transacting with a market on an event which\n * uses EtherToken as collateral, be sure to convert the ether into EtherToken by sending ether to\n * the deposit() method of the contract. For other ERC20 collateral tokens, follow the token's\n * acquisition process defined by the token's contract.\n *\n * Note: this method is asynchronous and will return a Promise\n *\n * @param {(Contract|string)} opts.market - The market to buy tokens from\n * @param {(number|string|BigNumber)} opts.outcomeTokenIndex - The index of the outcome\n * @param {(number|string|BigNumber)} opts.outcomeTokenCount - Number of outcome tokens to buy\n * @param {(number|string|BigNumber)} [opts.approvalAmount] - Amount of collateral to allow market to spend. If unsupplied or null, allowance will be reset to the `approvalResetAmount` only if necessary. If set to 0, the approval transaction will be skipped.\n * @param {(number|string|BigNumber)} [opts.approvalResetAmount] - Set to this amount when resetting market collateral allowance. If unsupplied or null, will be the cost of this transaction.\n * @returns {BigNumber} How much collateral tokens caller paid\n * @alias Gnosis#buyOutcomeTokens\n */\nexport async function buyOutcomeTokens() {\n    const [[marketAddress, outcomeTokenIndex, outcomeTokenCount], opts] =\n        normalizeWeb3Args(Array.from(arguments), {\n            methodName: 'buyOutcomeTokens',\n            functionInputs: [\n                { name: 'market', type: 'address' },\n                { name: 'outcomeTokenIndex', type: 'uint8'},\n                { name: 'outcomeTokenCount', type: 'uint256'},\n            ]\n        })\n\n    const txOpts = _.pick(opts, ['from', 'to', 'value', 'gas', 'gasPrice'])\n\n    let { approvalAmount, approvalResetAmount } = opts || {}\n\n    const market = await this.contracts.Market.at(marketAddress)\n    const collateralToken = await this.contracts.Token.at(\n        await this.contracts.Event.at(\n            await market.eventContract(txOpts)\n        ).collateralToken()\n    )\n    const baseCost = await this.lmsrMarketMaker.calcCost(marketAddress, outcomeTokenIndex, outcomeTokenCount, txOpts)\n    const cost = baseCost.add(await market.calcMarketFee(baseCost, txOpts))\n\n    if(approvalResetAmount == null) {\n        approvalResetAmount = cost\n    }\n\n    const txPromises = []\n    const txRequiredEventNames = []\n\n    if(approvalAmount == null) {\n        const buyer = txOpts.from || this.defaultAccount\n        const marketAllowance = await collateralToken.allowance(buyer, marketAddress, txOpts)\n\n        if(marketAllowance.lt(cost)) {\n            txPromises.push(collateralToken.approve(marketAddress, approvalResetAmount, txOpts))\n            txRequiredEventNames.push('Approval')\n        }\n    } else if(this.web3.toBigNumber(0).lt(approvalAmount)) {\n        txPromises.push(collateralToken.approve(marketAddress, approvalAmount, txOpts))\n        txRequiredEventNames.push('Approval')\n    }\n\n    txPromises.push(market.buy(outcomeTokenIndex, outcomeTokenCount, cost, txOpts))\n    txRequiredEventNames.push('OutcomeTokenPurchase')\n\n    const txRequiredEvents = (await Promise.all(txPromises))\n        .map((res, i) => requireEventFromTXResult(res, txRequiredEventNames[i]))\n    const purchaseEvent = txRequiredEvents[txRequiredEvents.length - 1]\n\n    return purchaseEvent.args.outcomeTokenCost.plus(purchaseEvent.args.marketFees)\n}\n\nbuyOutcomeTokens.estimateGas = async function({ using }) {\n    if(using === 'stats') {\n        return this.contracts.Token.gasStats.approve.averageGasUsed +\n            this.contracts.Market.gasStats.buy.averageGasUsed\n    }\n    throw new Error(`unsupported gas estimation source ${using}`)\n}\n\n\n/**\n * Sells outcome tokens. If transacting with a market which deals with EtherToken as collateral,\n * will need additional step of sending a withdraw(uint amount) transaction to the EtherToken\n * contract if raw ether is desired.\n *\n * Note: this method is asynchronous and will return a Promise\n *\n * @param {(Contract|string)} opts.market - The market to sell tokens to\n * @param {(number|string|BigNumber)} opts.outcomeTokenIndex - The index of the outcome\n * @param {(number|string|BigNumber)} opts.outcomeTokenCount - Number of outcome tokens to sell\n * @param {(number|string|BigNumber)} [opts.approvalAmount] - Amount of outcome tokens to allow market to handle. If unsupplied or null, allowance will be reset to the `approvalResetAmount` only if necessary. If set to 0, the approval transaction will be skipped.\n * @param {(number|string|BigNumber)} [opts.approvalResetAmount] - Set to this amount when resetting market outcome token allowance. If unsupplied or null, will be the sale amount specified by `outcomeTokenCount`.\n * @returns {BigNumber} How much collateral tokens caller received from sale\n * @alias Gnosis#sellOutcomeTokens\n */\nexport async function sellOutcomeTokens() {\n    const [[marketAddress, outcomeTokenIndex, outcomeTokenCount], opts] =\n        normalizeWeb3Args(Array.from(arguments), {\n            methodName: 'sellOutcomeTokens',\n            functionInputs: [\n                { name: 'market', type: 'address' },\n                { name: 'outcomeTokenIndex', type: 'uint8'},\n                { name: 'outcomeTokenCount', type: 'uint256'},\n            ]\n        })\n\n    const txOpts = _.pick(opts, ['from', 'to', 'value', 'gas', 'gasPrice'])\n\n    let { approvalAmount, approvalResetAmount } = opts || {}\n\n    const market = await this.contracts.Market.at(marketAddress)\n    const outcomeToken = await this.contracts.Token.at(\n        await this.contracts.Event.at(\n            await market.eventContract(txOpts)\n        ).outcomeTokens(outcomeTokenIndex)\n    )\n    const baseProfit = await this.lmsrMarketMaker.calcProfit(marketAddress, outcomeTokenIndex, outcomeTokenCount, txOpts)\n    const minProfit = baseProfit.sub(await market.calcMarketFee(baseProfit, txOpts))\n\n    if(approvalResetAmount == null) {\n        approvalResetAmount = outcomeTokenCount\n    }\n\n    const txPromises = []\n    const txRequiredEventNames = []\n\n    if(approvalAmount == null) {\n        const seller = txOpts.from || this.defaultAccount\n        const marketAllowance = await outcomeToken.allowance(seller, marketAddress, txOpts)\n\n        if(marketAllowance.lt(outcomeTokenCount)) {\n            txPromises.push(outcomeToken.approve(marketAddress, approvalResetAmount, txOpts))\n            txRequiredEventNames.push('Approval')\n        }\n    } else if(this.web3.toBigNumber(0).lt(approvalAmount)) {\n        txPromises.push(outcomeToken.approve(marketAddress, approvalAmount, txOpts))\n        txRequiredEventNames.push('Approval')\n    }\n\n    txPromises.push(market.sell(outcomeTokenIndex, outcomeTokenCount, minProfit, txOpts))\n    txRequiredEventNames.push('OutcomeTokenSale')\n\n    const txRequiredEvents = (await Promise.all(txPromises))\n        .map((res, i) => requireEventFromTXResult(res, txRequiredEventNames[i]))\n    const saleEvent = txRequiredEvents[txRequiredEvents.length - 1]\n\n    return saleEvent.args.outcomeTokenProfit.minus(saleEvent.args.marketFees)\n}\n\nsellOutcomeTokens.estimateGas = async function({ using }) {\n    if(using === 'stats') {\n        return this.contracts.Token.gasStats.approve.averageGasUsed +\n            this.contracts.Market.gasStats.sell.averageGasUsed\n    }\n    throw new Error(`unsupported gas estimation source ${using}`)\n}\n"]}